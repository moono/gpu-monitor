<!DOCTYPE html>
<html lang="en">
<head>
    <title>{{ page_title }}</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap.min.css') }}">
    <style>
        html {
            font-size: 1rem;
        }

        @media (min-width: 576px) {
            html {
                font-size: 1.25rem;
            }
        }

        @media (min-width: 768px) {
            html {
                font-size: 1.5rem;
            }
        }

        @media (min-width: 992px) {
            html {
                font-size: 1.75rem;
            }
        }

        @media (min-width: 1200px) {
            html {
                font-size: 2rem;
            }
        }
    </style>
</head>


<body>
<div class="container-fluid">
    {% for host_name, data in initial_chart_data %}
    <div class="row">
        <!-- Left space -->
        <div class="col-sm-1 col-md-1 col-lg-1 sidenav">
            <h3>{{ host_name }}</h3>
        </div>

        <div class="col-sm-5 col-md-5 col-lg-5">
            <canvas id="barChart_{{ host_name }}"></canvas>
        </div>
        <div class="col-sm-5 col-md-5 col-lg-5">
            <canvas id="pieChart_{{ host_name }}"></canvas>
        </div>

        <!-- Right space -->
        <div class="col-sm-1 col-md-1 col-lg-1 sidenav">
        </div>
    </div>
    {% endfor %}
</div>

<!-- Additional library scripts-->
<!-- jquery -->
<script src="{{ url_for('static', filename='js/jquery-3.3.1.min.js') }}"></script>

<!-- Bootstrap core JavaScript -->
<script src="{{ url_for('static', filename='js/bootstrap.min.js') }}"></script>

<!-- Chart.js-->
<script src="{{ url_for('static', filename='chartjs-2.7.3/Chart.min.js') }}"></script>

<!-- Custom script -->
<script type="text/javascript">

    // var dynamicColors = function () {
    //     var r = Math.floor(Math.random() * 255);
    //     var g = Math.floor(Math.random() * 255);
    //     var b = Math.floor(Math.random() * 255);
    //     return "rgb(" + r + "," + g + "," + b + ")";
    // };

    const predefinedColors = [
        'rgba(255,99,132,1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
    ];

    function createChartjsBarChartData (bar_chart_data) {
        const m_background_color = [];
        const m_border_color = [];
        const u_background_color = [];
        const u_border_color = [];
        for (let i = 0; i < bar_chart_data["labels"].length; i++) {
            m_background_color.push('rgba(54, 162, 235, 0.2)');
            m_border_color.push('rgba(54, 162, 235, 1)');
            u_background_color.push('rgba(255, 99, 132, 0.2)');
            u_border_color.push('rgba(255, 99, 132, 1)');
        }

        // create chart.js data and return
        return {
            labels: bar_chart_data["labels"],
            datasets: [{
                label: 'memory usage %',
                data: bar_chart_data["memory_data"],
                backgroundColor: m_background_color,
                borderColor: m_border_color,
                borderWidth: 1
            }, {
                label: 'utilization %',
                data: bar_chart_data["utilization_data"],
                backgroundColor: u_background_color,
                borderColor: u_border_color,
                borderWidth: 1
            }]
        };
    }

    function createChartjsPieChartData (pie_chart_data) {
        const background_color = [];
        for (let i = 0; i < pie_chart_data["labels"].length; i++) {
            let index = i % predefinedColors.length;
            background_color.push(predefinedColors[index]);
        }

        // create chart.js data and return
        return {
            labels: pie_chart_data["labels"],
            datasets: [{
                label: pie_chart_data["labels"],
                data: pie_chart_data["processes_data"],
                backgroundColor: background_color
            }]
        };
    }

    function updateChart (charts) {
        $.ajax({
            url: '/collect_all',
            type: 'GET',
            contentType: 'application/json; charset=utf-8',
            processData: false, // NEEDED, DON'T OMIT THIS

            success: function (data) {
                // console.log('Success!');
                // set new data for each charts
                for (let i = 0; i < data.length; i++) {
                    const host_name = data[i][0];
                    // const barElementID = "barChart_" + host_name;
                    // const pieElementID = "pieChart_" + host_name;
                    const bar_chart_data = createChartjsBarChartData(data[i][1]["bar_chart"]);
                    const pie_chart_data = createChartjsPieChartData(data[i][1]["pie_chart"]);

                    const bar_chart = charts[host_name]["bar"];
                    const pie_chart = charts[host_name]["pie"];
                    bar_chart.data = bar_chart_data;
                    pie_chart.data = pie_chart_data;
                    bar_chart.update(0);
                    pie_chart.update(0);
                }
            },
            error: function (data) {
                console.log('Error!!');
            }
        });
    }

    window.onload = function () {
        // get initial data
        const initialChartData = JSON.parse('{{ initial_chart_data | tojson | safe }}');

        // set initial values
        const charts = {};
        for (let i = 0; i < initialChartData.length; i++) {
            const host_name = initialChartData[i][0];
            const barElementID = "barChart_" + host_name;
            const pieElementID = "pieChart_" + host_name;
            const bar_chart_data = createChartjsBarChartData(initialChartData[i][1]["bar_chart"]);
            const pie_chart_data = createChartjsPieChartData(initialChartData[i][1]["pie_chart"]);

            // create bar charts and save
            charts[host_name] = {};
            const bar_ctx = document.getElementById(barElementID).getContext('2d');
            charts[host_name]["bar"] = new Chart(bar_ctx, {
                // type: 'horizontalBar',
                type: 'bar',
                data: bar_chart_data,
                options: {
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true,
                                max: 100,
                                //min: 0,
                                stepSize: 10
                            },
                            gridLines: {
                                offsetGridLines: true
                            }
                        }]
                    },
                    animation: {
                        onComplete: function () {
                            const ctx = this.chart.ctx;
                            ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontFamily, 'normal', Chart.defaults.global.defaultFontFamily);
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'bottom';

                            this.data.datasets.forEach(function (dataset) {
                                for (let i = 0; i < dataset.data.length; i++) {
                                    const model = dataset._meta[Object.keys(dataset._meta)[0]].data[i]._model,
                                        scale_max = dataset._meta[Object.keys(dataset._meta)[0]].data[i]._yScale.maxHeight;
                                    ctx.fillStyle = '#444';
                                    let y_pos = model.y - 5;
                                    // Make sure data value does not get overflown and hidden
                                    // when the bar's value is too close to max value of scale
                                    // Note: The y value is reverse, it counts from top down
                                    if ((scale_max - model.y) / scale_max >= 0.93)
                                        y_pos = model.y + 20;
                                    ctx.fillText(dataset.data[i], model.x, y_pos);
                                }
                            });
                        }
                    }
                }
            });

            const pie_ctx = document.getElementById(pieElementID).getContext('2d');
            charts[host_name]["pie"] = new Chart(pie_ctx, {
                type: 'polarArea',
                data: pie_chart_data,
            });
        }
        console.log("break point..");

        setInterval(function () {
            updateChart(charts)
        }, 1000);
    }

</script>

</body>
</html>
